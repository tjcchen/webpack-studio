import{existsSync as s}from"fs";import t,{defaultOptions as o}from"purgecss";import{ConcatSource as e}from"webpack-sources";import n from"path";function r(s,t){const o=n.extname((e=s).includes("?")?e.split("?").slice(0,-1).join(""):e);var e;return t.includes(o)}function i(s,t,o){const e=[];for(const r of Array.from(s.modulesIterable||[])){const s=o(r);s&&t.includes(n.extname(s))&&e.push(s)}return e}const a=[".css",".scss",".styl",".sass",".less"];export default class{constructor(s){this.purgedStats={},this.options=s}apply(s){s.hooks.compilation.tap("PurgeCSS",s=>{this.initializePlugin(s)}),s.hooks.done.tap("PurgeCSS",this.onHooksDone.bind(this))}onHooksDone(s){s.hasErrors()?this.options.verbose&&console.warn("purge-webpack-plugin: pausing due to webpack errors"):this.options.rejected&&(s.purged=this.purgedStats)}getAssetsToPurge(s,t){return s.filter(s=>this.options.only?this.options.only.some(t=>s&&s.name.includes(t)):s&&t.includes(s.name))}initializePlugin(t){t.hooks.additionalAssets.tapPromise("PurgeCSS",()=>{const o="function"==typeof this.options.paths?this.options.paths():this.options.paths;return o.forEach(t=>{if(!s(t))throw new Error(`Path ${t} does not exist.`)}),this.runPluginHook(t,o)})}async runPluginHook(s,n){const c=function(s={},t){const o=[];for(const[e,n]of Object.entries(s))r(e,t)&&o.push({name:e,asset:n});return o}(s.assets,[".css"]);for(const r of s.chunks){const{files:u}=r,p=this.getAssetsToPurge(c,u);for(const{name:c,asset:u}of p){const p=n.concat(i(r,this.options.moduleExtensions||[],s=>s.resource)).filter(s=>!a.some(t=>s.endsWith(t))),l={...o,...this.options,content:p,css:[{raw:u.source()}]};"function"==typeof l.safelist&&(l.safelist=l.safelist());const f=(await(new t).purge({content:l.content,css:l.css,defaultExtractor:l.defaultExtractor,extractors:l.extractors,fontFace:l.fontFace,keyframes:l.keyframes,output:l.output,rejected:l.rejected,variables:l.variables,safelist:l.safelist}))[0];f.rejected&&(this.purgedStats[c]=f.rejected),s.assets[c]=new e(f.css)}}}}
